import pyttsx3
import speech_recognition as sr

import tkinter as tk
import tkinter.filedialog

WIDTH = 1400
HEIGHT = 800

WHITE = "#FFFFFF"
DARKER_WHITE = "#DDDDDD"
BLACK = "#000000"
DARK_GREY = "#1C1C1C"
DARK_GREY_2 = "#101010"

RED = "#DC143C"
GREEN = "#00B300"
BLUE = "#3792CB"

class Application:
    def __init__(self):
        self.display = tk.Tk() 
        self.display.title("Speech to CAD Generator")
        self.display.geometry(str(WIDTH) + "x" + str(HEIGHT) + "+0+0")
        self.display.configure(bg=BLACK)
        
        self.parser = TextParser()
        header_height = 2
        self.recording = False
        
        
        record = tk.Frame(self.display, bg=DARK_GREY)
        record.grid(row = 0, column = 0)
        tk.Label(record, text="Audio Recording", height=header_height, bg=RED, fg=WHITE, font=("Karla", 22, 'bold'), width = 33).grid(row = 1, column = 0)
        tk.Label(record, text="Welcome to our fully automatic speach to STL file generator. To begin, please click on the record button and describe a simple shape for the system to generate!", bg=DARK_GREY, fg=WHITE, font=("Karla", 17), wraplength=400, pady = 15).grid(row = 2, column = 0)
        
        tk.Label(record, text="Open a .WAV filetype", height=header_height, bg=DARK_GREY_2, fg=WHITE, font=("Karla", 18, 'bold'), width = 25, pady=5).grid(row = 3, column = 0)
        tk.Button(record, text="Open File", highlightbackground = DARK_GREY, bg=DARK_GREY_2,command = self.open_file, font=("Karla", 18)).grid(row = 4, column = 0, pady = 5)
        
        tk.Label(record, text="Read Audio from Microphone", height=header_height, bg=DARK_GREY_2, fg=WHITE, font=("Karla", 18, 'bold'), width = 25, pady=5).grid(row = 5, column = 0)
        options = sr.Microphone.list_microphone_names()
        self.variable = tk.StringVar(self.display)
        self.variable.set(options[1]) # default value
        tk.OptionMenu(record, self.variable, *options).grid(row = 6, column = 0, pady = (5, 5))
        self.mic = self.create_audio_dropdown(record)
        tk.Button(record, text="Record", highlightbackground = DARK_GREY, fg=DARK_GREY_2, command = self.refresh_info, font=("Karla", 18)).grid(row = 7, column = 0, pady = 5)
        tk.Button(record, text="Exit", highlightbackground = DARK_GREY, fg=RED, command = self.exit, font=("Karla", 18)).grid(row = 8, column = 0, pady = 10)
        
        
        stt = tk.Frame(self.display, bg=DARK_GREY_2)
        stt.grid(row = 0, column = 1)
        tk.Label(stt, text="Text Parsing", height=header_height, bg=GREEN, fg=WHITE, font=("Karla", 22, 'bold'), width = 33).grid(row = 1, column = 1)
        tk.Label(stt, text="Below is the raw text heard by the STL software. An intelligent parsing algorithm will then search this text for useful terms.", bg=DARK_GREY_2, fg=WHITE, font=("Karla", 17), wraplength=400, pady = 15).grid(row = 2, column = 1)
        self.current_text = tk.Text(stt, width = 32, height = 15, bg=DARK_GREY_2, highlightbackground = DARK_GREY, fg=DARKER_WHITE, highlightcolor = "#7BAEDC", wrap = tk.WORD, font=("Karla", 16), pady=5)
        self.current_text.grid(row = 3, column = 1, padx = 1)
        tk.Button(stt, text="Update Parsing", highlightbackground = DARK_GREY, bg=DARK_GREY_2, command = self.refresh, font=("Karla", 18)).grid(row = 4, column = 1, pady = 10)
        self.final_info = tk.Text(stt, width = 32, height = 10, bg=DARK_GREY_2, highlightbackground = DARK_GREY, fg=DARKER_WHITE, highlightcolor = "#7BAEDC", wrap = tk.WORD, font=("Karla", 16), pady=10)
        self.final_info.grid(row = 5, column = 1, padx = 1)
        
        
        view = tk.Frame(self.display, bg=DARK_GREY)
        view.grid(row = 0, column = 2)
        tk.Label(view, text="STL Synthesization", height=header_height, bg=BLUE, fg=WHITE, font=("Karla", 22, 'bold'), width = 33).grid(row = 1, column = 2)
        tk.Label(view, text="Once the terms are found and organized, an STL file is generated by calling Fusion360 API methods.", bg=DARK_GREY, fg=WHITE, font=("Karla", 17), wraplength=400, pady = 15).grid(row = 2, column = 2)
        
        # The below code is a workaround that allows us to determine the window size in
        # pixels and then position the window wherever we want before drawing it.
        self.display.withdraw()
        self.display.update_idletasks()
        
        self.display.deiconify()
        self.display.mainloop()
        
    def create_audio_dropdown(self, master):
        options = sr.Microphone.list_microphone_names()
        variable = tk.StringVar(master)
        variable.set(options[0]) # default value

        w = tk.OptionMenu(master, variable, *options)
        return variable

    def exit(self):
        self.root.destroy()
        quit()
        
    def open_file(self):
        filename = tk.filedialog.askopenfilename(initialdir = "/",title = "Select file",filetypes = [("WAV files","*.wav")])
        print (filename)
        self.refresh_info(filename)
        
    def refresh_info(self, file = None):
        new_text = self.record(file)
        self.set_text(new_text)
        created_object_list = self.parser.text_to_objects(new_text)
        self.final_info.delete(1.0,"end")
        self.final_info.insert(1.0, '\n'.join(str(elem) for elem in created_object_list))
        
        f = FusionScriptGenerator('./Fusion Scripts/FusionScript1/FusionScript1.py')
        for elem in created_object_list:
            f.add_object(elem)
        f.close_generator()
    
    def refresh(self):
        text = self.current_text.get("1.0",'end-1c')
        created_object_list = self.parser.text_to_objects(text)
        self.final_info.delete(1.0,"end")
        self.final_info.insert(1.0, '\n'.join(str(elem) for elem in created_object_list))
        fusion_script_generator = FusionScriptGenerator('./Fusion Scripts/FusionScript1/FusionScript1.py')
    
        for elem in created_object_list:
            fusion_script_generator.add_object(elem)
        
        fusion_script_generator.close_generator()
        
    def record(self, file = None):
        print("Recording Audio from " + self.variable.get())
        self.recording = True
        r=sr.Recognizer()
        index = sr.Microphone.list_microphone_names().index(self.variable.get())
        inputing = sr.Microphone(device_index=index)
        if file != None:
            inputing = sr.AudioFile(file)
        with inputing as source:
            #r.adjust_for_ambient_noise(source, duration=3)
            # r.energy_threshold()
            print("say anything : ")
            audio = r.listen(source, timeout=10.0)
            try:
                text = r.recognize_google(audio)
                print(text)
                self.recording = False
                # self.set_text(text)
                return text
            except:
                print("sorry, could not recognize")
                
    def set_text(self, text):
        #self.current_text.delete(1.0,"end")
        self.current_text.insert(1.0, text)
    
    def update(self, b = None):
        print(self.current_text.get("1.0",'end-1c'))
        
    def speak(self, text):
        engine = pyttsx3.init()
        engine.say(text) 
        engine.runAndWait()


class TextParser():
    def __init__(self) -> None:
        self.options = {
            Cube : ('cube', 'box'),
            Sphere : ('sphere', 'ball'),
            Cylinder : ('cylinder', 'barrel'),
        }

        temp_new_dict = {}
        for key, value_tuple in self.options.items():
            for value in value_tuple:
                temp_new_dict[value] = key
        # self.all_stopwords = set(stopwords.words('english'))

        self.options = temp_new_dict
    
    def text_to_objects(self, raw_text): # returns a list of objects that were specificed by this text. Some objects may have missing arguments
        all_words = self._pre_process_text(raw_text)
        created_objects = []
        starting_index = [index for index, elem in enumerate(all_words) if elem in self.options][0]


        object_in_progress = self.options[all_words[starting_index]]()
        possible_properties = object_in_progress.get_prop_list()
        loaded = False
        property = None
        value = None
        for word in all_words[starting_index : ]:
            if word in possible_properties:
                property = word
                if loaded:
                    object_in_progress.set_prop(property, value)
                    loaded = False
                    property = None
                    value = None
                else:
                    loaded = True
            try:
                value = int(word)
                if loaded:
                    object_in_progress.set_prop(property, value)
                    loaded = False
                    property = None
                    value = None
                else:
                    loaded = True
            except ValueError:
                pass
            
            
            if word in self.options:
                created_objects.append(object_in_progress)
                object_in_progress = self.options[word]()
                possible_properties = object_in_progress.get_prop_list()
                loaded = False
                property = None
                value = None
        created_objects.append(object_in_progress)
        return created_objects[1 : ]

    def _pre_process_text(self, raw_text):
        # pre_processed_text = word_tokenize(raw_text)
        # TODO add lemmatization
        # pre_processed_text = word_tokenize(raw_text)
        pre_processed_text = raw_text.split()
        pre_processed_text = [elem.lower() for elem in pre_processed_text]
        return pre_processed_text


class FusionScriptGenerator():
    
    def __init__(self, filename):
        self.filename = filename
        self._closing_lines = None
        self.objects = []
        self.sketches = ['sketch']

        with open(self.filename, 'w') as target_file:
            with open('./Fusion Scripts/FusionScriptShell/FusionScriptShell.py') as source_file:
                source_lines = source_file.readlines()
                line_divider = [index for index, elem in enumerate(source_lines) if '"""' in elem][0]
                target_file.write(''.join(source_lines[ : line_divider]))
                self._closing_lines = ''.join(source_lines[line_divider : ])
    
    def add_object(self, object):
        with open(self.filename, 'a') as target_file:
            target_file.write('        ' + object.to_string_fusion() + '\n')
    
    def close_generator(self):
        with open(self.filename, 'a') as target_file:
            target_file.write(self._closing_lines)

class ExtrudedObject3D:
    """
    Abstract class that represents all 3d objects. These can be simple objects like Cubes and Spheres, or can be more complex objects that use a sketch and a length to extrude.
    """

    def __init__(self, sketch_profile='sketch.profiles[-1]', extrude_distance=None):
        self.object_type = 'Extruded Sketch'
        self.properties = {'sketch_profile' : sketch_profile, 'extrude_distance' : extrude_distance}

    def get_needed_properties(self):
        needed_properties = [elem for elem in self.properties if self.properties[elem] is None]
        return needed_properties # list of strings
    
    def to_string_display(self):
        """
        Returns a string that can be used to display the object in a human-readable format.
        """
        return_string = self.object_type + ', '.join([elem for elem in self.properties.items()])
        return return_string

    def to_string_fusion(self):
        """
        Returns a string that can be used to create the object using the Fusion API. Implemented in each subclass.
        """
        return_str = f"        extrudeDistance = adsk.core.ValueInput.createByReal({self.properties['extrude_distance']})\n        extrude = rootComp.features.extrudeFeatures.addSimple({self.sketch_profile}, extrudeDistance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)"
        return return_str
    
    def set_prop(self, property_name, value):
        self.properties[property_name] = value
    
class PrimitiveObject3D:
    """
    Abstract class that represents all 3d objects. These can be simple objects like Cubes and Spheres, or can be more complex objects that use a sketch and a length to extrude.
    """

    def __init__(self, sketch_profile='sketch.profiles[-1]', extrude_distance=None):
        self.object_type = 'Extruded Sketch'
        self.properties = {}
        self.alternative_properties = set()

    def get_needed_properties(self):
        needed_properties = [elem for elem in self.properties if self.properties[elem] is None]
        return needed_properties # list of strings
    
    def is_complete(self):
        return len(self.get_needed_properties()) == 0
    
    def __str__(self) -> str:
        return_string = self.object_type[0].upper() + self.object_type[1 : ].lower() + ' || ' + ', '.join([elem[0] + ': ' + str(elem[1]) for elem in self.properties.items()])
        return return_string

    def to_string_fusion(self):
        """
        Returns a string that can be used to create the object using the Fusion API. Implemented in each subclass.
        """
        return_str = f"This method needs to be implemented in {self.object_type}"
        return return_str
    
    def set_prop(self, property_name, value):
        if property_name not in self.properties:
            raise Exception(f'{property_name} is not a property of {self.object_2d_name}')
        self.properties[property_name] = value
    
    def set_next_prop(self, value):
        for key in self.properties:
            if self.properties[key] == None:
                self.set_prop(key, value)
                return None
        raise Exception(f'Attempted to add more properties than {self.object_type} has.')
    
    def get_prop(self, property_name):
        if property_name not in self.properties:
            raise Exception(f'{property_name} is not a property of {self.object_2d_name}')
        return self.properties[property_name]
    
    def get_prop_list(self):
        return set(self.properties.keys()).union(self.alternative_properties)
    
class Sphere(PrimitiveObject3D):
    
    def __init__(self, radius=None):
        super().__init__()
        self.object_type = 'sphere'
        self.properties.update({'radius' : radius})
        self.alternative_properties.update({'diameter'})

    def set_prop(self, property_name, value):
        if property_name in self.alternative_properties:
            if property_name == 'diameter':
                self.set_prop('radius', value / 2)
                return
        # function in the super class handles values that are in self.properties
        return super().set_prop(property_name, value)

    def to_string_fusion(self):
        circle = Circle(radius = self.get_prop('radius'))
        part1 = circle.to_string_fusion()
        part2 = """
        # DRAWWING A SPHERE
        axisLine = sketch.sketchCurves.sketchLines.addByTwoPoints(adsk.core.Point3D.create(-1 * %d, 0, 0), adsk.core.Point3D.create(%d, 0, 0))
        revolves = rootComp.features.revolveFeatures
        revInput = revolves.createInput(sketch.profiles[-1], axisLine, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        revInput.setAngleExtent(False, adsk.core.ValueInput.createByReal(2 * math.pi))
        ext = revolves.add(revInput)
        """ % (self.get_prop('radius'), self.get_prop('radius'))
        
        return part1 + part2
    
class Cylinder(PrimitiveObject3D):
    
    def __init__(self, radius=None, height=None):
        super().__init__()
        self.object_type = 'cylinder'
        self.properties.update({'radius' : radius, 'height' : height})
        self.alternative_properties.update({'diameter'})

    def set_prop(self, property_name, value):
        if property_name in self.alternative_properties:
            if property_name == 'diameter':
                self.set_prop('radius', value / 2)
                return
        # function in the super class handles values that are in self.properties
        return super().set_prop(property_name, value)

    def to_string_fusion(self):
        # Make a new circle with radius "radius"
        circle = Circle(radius = self.get_prop('radius'))
        part1 = circle.to_string_fusion()
        # Extrude the circle by height "height"
        part2 = f"# DRAWING A CYLINDER\n        extrude = rootComp.features.extrudeFeatures.addSimple(sketch.profiles[-1], adsk.core.ValueInput.createByReal({self.get_prop('height')}), adsk.fusion.FeatureOperations.NewBodyFeatureOperation)\n"
        return part1 +  "        " + part2    

class Cube(PrimitiveObject3D):
    
    def __init__(self, side_length=None):
        super().__init__()
        self.object_type = 'cube'
        self.properties.update({'side_length' : side_length})

    def to_string_fusion(self):
        square = Square(side_length=self.get_prop('side_length'))
        part1 = square.to_string_fusion()
        # Extrude the circle by height "height"
        part2 = f"# DRAWING A CUBE\n        extrude = rootComp.features.extrudeFeatures.addSimple(sketch.profiles[-1], adsk.core.ValueInput.createByReal({self.get_prop('side_length')}), adsk.fusion.FeatureOperations.NewBodyFeatureOperation)\n"
        return part1 +  "        " + part2
    
class Object2D:

    def __init__(self) -> None:
        self.object_type = None
        self.sketch_plane = None
        self.properties = {'sketch_plane' : 'sketch'}
    
    def get_needed_properties(self):
        needed_properties = [elem for elem in self.properties if self.properties[elem] is None]
        if self.object_2d_name is None:
            raise Exception('This Object2D subclass needs a name')
        if self.sketch_plane is None:
            needed_properties.append('surface')
        return needed_properties # list of strings
    
    def to_string_display(self):
        """
        Returns a string that can be used to display the object in a human-readable format.
        """
        return_string = self.object_type + ', '.join([elem for elem in self.properties.items()])
        return return_string

    def to_string_fusion(self):
        """
        Returns a string that can be used to create the object using the Fusion API. Implemented in each subclass.
        """
        return 'The to_string_fusion method needs to be implemented in class:' + self.object_type
    
    def set_prop(self, property_name, value):
        if property_name not in self.properties:
            raise Exception(f'{property_name} is not a property of {self.object_2d_name}')
        self.properties[property_name] = value
    
    def get_prop(self, property_name):
        if property_name not in self.properties:
            raise Exception(f'{property_name} is not a property of {self.object_2d_name}')
        return self.properties[property_name]
    
class Rectangle(Object2D):
    def __init__(self, width=None, height=None):
        super().__init__()
        self.object_type = 'Rectangle'
        self.properties.update({'width' : width, 'height' : height})
    
    def to_string_fusion(self):
        return_string = f"sketch = rootComp.sketches.add(rootComp.xYConstructionPlane)\n        rec1 = {self.get_prop('sketch_plane')}.sketchCurves.sketchLines.addTwoPointRectangle(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create({self.get_prop('width')}, {self.get_prop('height')}, 0))\n"
        return return_string
    
class Square(Object2D):
    def __init__(self, side_length=None):
        super().__init__()
        self.object_type = 'Square'
        self.properties.update({'side_length' : side_length})

    def to_string_fusion(self):
        return_string = f"sketch = rootComp.sketches.add(rootComp.xYConstructionPlane)\n        rec1 = {self.get_prop('sketch_plane')}.sketchCurves.sketchLines.addTwoPointRectangle(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create({self.get_prop('side_length')}, {self.get_prop('side_length')}, 0))\n"
        return return_string
    
class Circle(Object2D):
    def __init__(self, radius=None):
        super().__init__()
        self.object_type = 'Circle'
        self.properties.update({'radius' : radius})
    
    def to_string_fusion(self): # remove this default eventually
        return_string = f"sketch = rootComp.sketches.add(rootComp.xYConstructionPlane)\n        circles = {self.get_prop('sketch_plane')}.sketchCurves.sketchCircles.addByCenterRadius(adsk.core.Point3D.create(0, 0, 0), {self.get_prop('radius')})\n"
        return return_string
    
if __name__=="__main__":
    Application()